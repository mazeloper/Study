
### JIT 컴파일러

프로그램 실행방식에는 두 가지 방식 있다.
- 인퍼프리트
	- 프로그램이 실행 할 때마다 변환 작업을 수행한다.
- 정적 컴파일
	- 변환 작업은 처음 딱 한번만 수행된다.

이 두 가지 방식에는 장/단점이 있고 이를 혼합한게 `JIT 컴파일러` 다.
컴파일 시 필요한 코드들의 정보를 캐시(메모리)에 저장해두었다가 다음 컴파일 시 재사용한다.

### Hospot Client Compiler vs Hospot Server Compiler

Client Compiler 는 CPU 코어가 하나뿐인 사용자를 위한 것이며, 시작 시간이 빠르고 메모리 점유를 낮게 사용한다
Server Compiler 는 코어가 많은 장비에서 돌리기 위한 컴파일러 이며 수행속도에 초점이 맞추어져 있다


### JVM

자바 프로그램이 수행되는 프로세스이며 모든 자바 응용프로그램은 JVM 위에서 실행된다.
JVM 에는 객체들을 관리하는 heap 메모리 공간이라는게 존재한다.

#### 기본자료형은 heap 이 아닌 스택에 저장된다.

기본 자료형은 heap 에 저장되어 관리되는게 아닌 스택 영역에 저장된다. 
그 이유는 계산할 때 더 빠르게 처리가 가능하기 때문이다. 

#### 더 빠른 이유가 뭔데
1. 스택은 후입선출 방식이며 이 때문에 메모리 할당 및 할당 해제가 신속하게 수행된다.
2. 메서드를 실행할 때 각 스레드는 일반적으로 자체 스택 프레임을 갖기 때문에 스택은 본질적으로 스레드로부터 안전하다.
3. 기본 자료형을 스택에 저장하면 오버헤드가 최소화된다. 스택의 데이터에 액세스하는 것은 간단한 포인터 산술을 포함하므로 일반적으로 힙의 데이터를 가져오는것보다 빠르다.

> [!스레드]
> 프로세스내에서 실제로 작업을 수행하는 주체. 자바는 멀티 쓰레드를 지원한다

> [!프로세스]
> 프로세스란 단순히 실행중인 프로그램이라고 할 수 있다.
> 사용자가 작서한 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것을 말한다.
> 작업끝내기를 누르고 나오는 프로세스 목록이 위 내용과 같다.

> [!포인터]
> 위 맥락에서는 다른 변수의 메모리 주소를 저장하는 변수를 나타낸다.
> C, C++ 에서의 포인터는 메모리를 관리하고 메모리에 저장된 데이터를 액세스하는데 명시적으로 사용된다.
> 
> 스택에 변수가 있을 때 포인터를 통해 메모리 위치를 참조하여 해당 값에 직접 액세스할 수 있다라는 의미이다.
> 힙에 필요한 것과 같은 복잡한 조회, 관리 작업을 포함하지 않기 때문에 효율적이다.



만약 객체로 처리해야 할 때가 있다면 각 기본형 타입에 맞는 클래스들이 존재하며 해당 클래스들을 사용할 수 있다 (Integer, Character, Byte ... etc)
이러한 클래스들을 사용하는 이유에는 여러가지가 존재한다.
1. 제네릭 사용 시 ( 기본 자료형에 대한 사용이 불가)
2. 클래스에 선언된 상수 및 수 많은 메서드들을 사용하기 위해 (MAX_VALUE, parse()... )




### 제네릭이란?

제네릭은 타입 형 변환에서 발생할 수 있는 문제점을 사전에 없애기 위해 만들어 졌다.
여기서 "사전" 은 런타임오류가 아닌 컴파일 시 점검할 수 있도록 한 것이다.


```Java
public class GenericSample {
	public static void main(String[] args) {
		checkCastingDTO();
	}
	public static void checkCastingDTO() {
		CastingDTO dto1 = new CastingDTO();
		dto1.setObject(new String());

		CastingDTO dto2 = new CastingDTO();
		dto2.setObject(new StringBuffer());

		CastingDTO dto3 = new CastingDTO();
		dto3.setObject(new StringBuilder);
	}
}

public class CastingDTO {
	private Object object;

	public void setObject(Object object) {
		this.object = object;
	}
	public Object getObject() {
		return this.object;
	}
}
```

위 소스는 정상이다 하지만 각각의 참조변수에서 값을 가져와 새로운 객체에 전달한다면 어떻게 해야할까??


```Java
String temp1 = (String) dto1.getObject();
StringBuffer temp2 = (StringBuffer) dto2.getObject();
```

위와 같이 형 변환이 필요하고 혹시 모를 형 변환 실수를 방지하기 위해 `instanceof` 예약어를 통해 체크를 해야하는 불편함이 있다. 이런 단점을 보안하기 위해 추가된게 `제네릭` 이다.


```Java
public class CastingDTO<T // 별칭일뿐이다.> {
	private T object;

	public void setObject(T object){ ...}
	public T getObject() { ...}
}

public void checkGenericDTO() {
	CastingDTO<String> dto1 = new CastingDTO<String>();
	CastingDTO<StringBuffer> dto2 = new Casting<StringBuffer>();
	...
	String temp1 = dto1.getObject();
	StringBuffer temp2 = dto2.getObject();
}
```

제네릭을 사용하면 형 변환을 할 필요가 없어졌다. 각 객체에 선언되어 있는 제네릭 타입은 각 String, StringBuffer 이기 때문에 만약 temp1에 대한 타입을 StringBuffer 로 선언하였을 경우 컴파일 자체가 되지 않는다. 따라서 예외가 발생하지 않는다.
**이와 같이 명시적으로 타입을 지정할 때 사용하는 것이 제네릭이다.**

