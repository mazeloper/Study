#자바의신 #Java #Book 

![자바의 신](https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9791193229019.jpg)

### Pass By Value vs Pass By Reference

메서드에 매개변수를 전달할 때 기본형과 참조형에 대한 타입에 따라 값이 전달되는 방식이 다르다.
기본형은 (char, byte, short, int, long, float, double, boolean) 해당 값 그 자체를 전달한다.
참조형은 해당 객체가 있는 메모리 주소를 전달한다. 

```Java
// 기본형
int intValue = 0;
test(intValue);
System.out.print(intValue); // 0

public void test(int i) {
	i = 5;
}

// 참조형
String strValue = "Hi";
test2(strValue);
System.out.println(strValue); // Hi

public void test(String s){ 
	s = "bye";
}
```

**참조형 타입은 해당 객체의 메모리 주소를 전달한다고 했다. 근데 왜 참조형 타입에 String은 영향을 끼치지 않는가?**
위 소스에서 `s = "bye";` 은 s = `new String("bye");` 와 같다. 새로운 객체가 생성되는 것이며 이전에 매개변수로 전달한 strValue는 메모리 주소만 전달해 준것이지 해당 변수 자체를 전달한게 아니기 때문에 strValue 에는 아무런 영향이 없다.  

String 은 불변성 규칙을 갖고 있으며 새로운 값이 전달되면 값이 변경되는게 아닌 새로운 객체가 생성되며 이전에 사용했던 메모리 주소를 참조하는 경우가 존재하지 않다면 GC 로 인해 힙 메모리 에서 제거된다.


### 임의 개수의 매개변수 전달

가변인자란 같은 타입의 매개변수이고 여러개의 매개변수가 전달되는 경우 메서드 작성 시 매개변수에 부분을 더 간단하게 작성할 수 있게 해준다. 가변인자 타입의 매개변수는 무조건 메서드 매개변수 항목에서 마지막에 작성되어야 한다.

```Java
test("h", "i", "b", "y", "e")
public void test(String...args) {
   ...
}
```
**가변인자는 내부적으로 배열을 만들기 때문에 적은 개수인 경우 하나 하나 매개변수 타입을 정의해주는 게 좋다.**


### Package

패키지란 디렉토리 개념이며 각 패키지 별로 비슷한 성격의 파일들을 분류한다.
패키지의 특성 및 작성 시 조심해야할 부분들이 몇 가지 있다.
- 소스의 가장 첫 줄에 위치한다
- 패키지 선언은 소스 하나당 하나만 존재할 수 있다.
- 패키지 이름과 실제 파일 위치가 같아야 한다.
- 패키지 이름이 `java` 로 시작하면 안된다.
- 자바의 예약어(`static`, `final` ...) 가 포함되면 안된다.
- 패키지가 다를 경우 같은 이름의 클래스를 생성할 수 있다.

### Import
I
mport란 컴파일러가 클래스 이름을 확인할 수 있도록 하는 것이다.
- 다른 패키지에 클래스를 찾을 때 사용
- 정적변수나 메서드도 사용 가능하다.
	- 다른 패키지에 있는 정적변수 및 메서드가 import 되어있고 현재 클래스에서도 동일한 정적변수 또는 메서드가 존재할 경우 자신의 클래스에 있는게 우선이 된다.

### 접근제어자

접근제어자는 변수나 메서드, 클래스에 대한 사용 권한을 설정할 수 있다.
- public
	- 모든 곳에서 접근이 가능하다.
- protected
	- 같은 패키지내 또는 상속받은 클래스에서만 접근이 가능하다.
- non-private(default)
	- 접근제어자를 작성하지 않을 때 자동으로 설정되는 제어자이며 같은 패키지에서만 접근이 가능하다.
- private
	- 해당 클래스 파일에서만 접근이 가능하다.


### 상속

상속 시 부모클래스의 변수 및 메서드를 사용할 수 있다.
부모클래스에 기본생성자만 존재하는 경우, 자식클래스에서 기본생성자 사용 시 컴파일단계에서 자동으로 부모클래스에 대한 기본생성자를 호출한다.

하지만 기본 생성자가 아닌 경우 자식클래스 생성자에서 `super` 예약어를 사용하여 부모클래스에 대한 생성자를 직접 호출하여야 한다.

상속은 객체지향언어에 중요한 특징이며 여러 곳에서 같은 클래스를 상속한 경우 공통적으로 사용하는 변수나 메서드에 대해 부모클래스에서 수정을 진행하게 되면 모든 곳에서 일일이 수정할 필요가 없어 유지보수 측면에서 매우 좋다.

또한 부모클래스에 메서드가 `final` 예약어가 적혀있지 않다면 자식 클래스에 `오버라이딩` 하여 함수를 재정의하여 사용할 수 있다.

자식클래스가 되는 클래스에서는 **상속을 한 클래스에 대해서만 할 수 있다.**

```Java
public class Child extends Parent, Paren2 { // 2개 이상의 클래스를 상속할 수 없다.
	...
}
```

#### 참조형에서의 상속
- 자식 객체 생성 시 부모 생성자를 사용할 수 없다.
- 부모 객체 생성 시 자식 생성자를 사용할 수 있다.
**자식 객체는 부모의 모든것을 갖고있어서 부모객체로 객체를 생성할 수 있다.**
또한 형 변한 같은 경우 아래와 같은 케이스에서만 변환이 가능하다.


```Java
Child c = new Child();
Parent p = c;
Parent p2 = new Parent();

Child c2 = (Child) p; // 형 변환에 대해 명시적으로 작성해줘야한다.
Child c3 = (Child) p2; // 컴파일 에러가 발생한다.
```

p1, p2 변수도 Parent 객체를 참조하고 있는데 왜  p변수만 Child 로 형 변환이 가능할까??

그 이유는 2번째 라인에서 `Parent p = c;`  p는 부모객체에 대한 메모리 주소를 참조하는게 아닌
**부모객체에 대한 것만 사용할 수 있게 제한된 자식 객체이다.** 

#### intanceof
자바의 예약어이며 해당 클래스의 타입인지 확인하는 용도를 쓰인다.
해당 예약어를 사용할 때는 자식타입을 먼저 체크해야한다. 이유는 아래 코드를 보면 안다.

```Java
Child c = new Child();

if(c instanceof Parent) {}
else if(c instanceof Child) {}

// 부모타입도 true 로 리턴된다.
// 정확한 타입에 대해 확인하고 싶다면 자식 클래스에 대한 정보먼저 확인하여야 한다.
```

### 다형성
객체지향언어에 큰 특징 중 하나이며 "하나의 객체가 여러개의 타입을 가질 수 있는 것" 을 뜻한다.
부모클래스 타입 참조변수로 자식 타입의 인스턴스를 참조할 수 있다.

```Java
Parent p = new Child();
p.func() ... // 자식 인스턴스에 대한 func 함수가 호출된다.

public class Child extends Parent {
   @Override
   public void func() {
       ...
   }
}
```

### BigDecimal
double, float 과 같은 부동 소수점을 기반으로 하는 실수형 타입에서 부동 소수점 표현 방식의 오차를 해결하기 위한 클래스 이다.

```Java
//생성자에는 실제 실수형 데이터가 아닌 String 값을 넣어줘야야 한다.
BigDecimal b = new BigDecimal("12.25"); 
```


### 모든 클래스의 부모 클래스는 Object 에요
모든 클래스는 자동으로 java.lang.Object 클래스를 상속받는다.
우리가 객체를 생성한 후 작성하지 않았던 `equals()`, `toString()` 과 같은 메서드를 사용할 수 있는거는 자동으로 상속받은 Object 클래스에 명시되어 있는 메서드 들이다.

### Interface vs abstract Class
인터페이스와 추상클래스의 차이점과 공통점은 무엇이 있을까?

공통점
- 설계 시 선언만 해두면 개발 시, 기능 구현에만 집중할 수 있다
- 개발자 역량에 따라 메서드 이름, 매개변수 선언의 격차를 줄일 수 있다.
- 선언과 구현을 구분할 수 있다.

#### Interface
상속은 오로지 1개의 클래스에 대해서만 가능하지만 인터페이스는 여러개를 구현할 수 있다.
인터페이스를 구현하는 경우 구현체가 되는 클래스에서 반드시 인터페이스에서 정의된 메서드에 대해 `override` 하여야 한다.
인터페이스에서 작성하는 메서드 같은 경우 중괄호를 사용하지 않는다. (인터페이스 내에서 메서드 내용을 작성할 수 없다,)


#### abstract Class
추상클래스도 결국 클래스이므로 다중상속이 불가능하다. 인터페이스와 달리 추상 클래스는 구현되어 있는 메서드가 있어도 상관없다. 구현하는 클래스 내에서 해당 메서드 또한 오버라이딩 할 수 있으며 `abstract` 예약어가 붙은 메서드같은 경우 반드시 구현 클래스에서 작성을 해주어야 한다. 일반 클래스도 마찬가지고 추상클래스도 오버라이딩을 시키지 않고 싶은 경우 해당 메서드에 `final` 키워드를 붙혀주면 된다.

### Enum
Enum 은 상수(변하지 않는 값)의 집합이다.
switch 문에서 자주 사용되면 값을 쓸 때는 정적변수를 사용한 것과 같다 (EnumClassName.상수값)

Enum 생성자는 만들 수 있지만 객체 생성은 안된다. 

```Java
public enum Over {
	T(1000), // 이게 외부에서 사용하는 생성자와 같다.
	E(2000);

	private final int value;
 
    // 생성자
    Over(int value) {
	    this.value = value;
    }
    public itn getValue() {
	    retrun value
    }
}

// 사용
Over o = Over.T;
o.getValue() // 1000
```

### String
String 은 매우 특별한 클래스이다. 해당 부문은 추후에 자세하게 작성
String은 불변성의 규칙을 갖고있다. String 변수에 값이 변경되면 말 그대로 값 변경이 아닌 새로운 객체를 생성하여 새로운 메모리 공간을 갖는다.

#### StringBuffer vs StringBuilder
이런 String 불변성을 해결하기 위해 StringBuffer 와 StringBuilder 클래스가 있따.

- StringBuffer
	- 쓰레드에 더 안전하며 속도는 `StringBuilder` 보다 느리다.
- StringBuilder
	- 쓰레드에 안전하지 않으며 속도는 `StringBuffer` 보다 빠르다.


**어떤 클래스에 문자열을 생성하여 더하기 위한 문자열 처리를 위해 인스턴스 변수가 생성되었고 여러 쓰레드에서 동시에 접근 가능하면 StringBuffer 를 사용해라**