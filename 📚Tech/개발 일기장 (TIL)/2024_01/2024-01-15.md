한주동안 공부했던 내용 간략하게 정리

### 자바 가상 머신 (JVM)

#### JVM 구조
- 클래스 로더
- 실행엔진
- 런타임 데이터 영역

![JVM구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcm4eqM%2FbtrNhvlb7jv%2FHOItiM00iRnH8Gg29yYcH0%2Fimg.png)
[출처 : https://jhyonhyon.tistory.com/17](https://jhyonhyon.tistory.com/17)


#### 클래스 로더
 JVM 내로 클래스 파일 (\*.class) 을 동적으로 로드하고 링크를 통해 JVM 메모리 영역 (Runtime Data Area)에 배치하는 작업을 수행한다

로딩 -> 링크 -> 초기화 순서로 진행된다.

- 로딩 : 클래스 로더가 .class 파일을 읽고 그 내용에 따라 적절한 바이너리 데이터 (0,1)를 만들어 메서드 영역에 배치한다. 로딩이 끝나면 해당 클래스 타입의 Class 객체를 생성하여 "heap" 영역에 저장한다.

- 링크 : Verify (확인) -> Prepare (준비) -> Resolve (해결) 순으로 이루어져 있다.

- 초기화 : static 변수의 값을 할당하고 static 블럭은 이때 실행된다.


#### 데이터 영역
- 메소드 영역
	- 메서드 영역에서는 런타임 상수풀 (Constant Pool), 필드와 메서드 데이터 내용, 즉 클래스 수준의 정보를 저장한다.
	  (클래스 구조, 메서드 코드, 정적 변수)
	  
- 힙 영역
	- 인스턴스화된 모든 클래스의 인스턴스(객체) 들을 저장한다. 해당 영역에 할당된 메모리들은 실행엔진에 있는 가비지컬렉션을 통해서만 제거된다.
	  
	  (객체와 배열을 저장)
- 스택 영역
	- 쓰레드마다 자체 런타임 스팩을 만들고 , JVM 스택에는 프레임에 저장된다. 메서드가 하나 호출될 때 마다 새 프레임이 생성되어 스택에 쌓이고, 완료되거나 예외를 던졌을 경우 프레임은 스택 영역에서 소멸된다. 또한 스레드가 종료되면 스택도 제거된다. 
	  
	  (로컬 변수, 매개변수, 리턴 값 및 임시데이터를 저장)
- PC 레지스터
	- 현재 실행중인 메서드가 네이트브가 아니면, 현재 실행중인 JVM 명령어 위치에 저장되고, 네이티브면 PC 레지스터에 저장되는 값은 정의되지 않는다. CPU의 Register와는 다른거이며, 연산을 위해 필요한 피연산자를 임시로 저장하기 위한 용도로 저장된다.
- 네이티브 메소드 영역
	- JVM 영역이 아닌 C스택을 말한다. 

#### 실행엔진
클래스로더를 통해 데이터 영역에 배치된 바이트코드를 명령어 단위로 읽어서 실행한다.
- 인터프리트 방식
	- 명령어를 하나씩 읽어서 해석하고 실행한다. 이 과정에서 바이트코드가 기계어로 변환된다. 하나씩 읽으므로 매우 느리다.
- JIT 방식
	- 정적 컴파일 (변환 작업이 딱 한번만 이루어지는 컴파일) 과 인터프리트 방식을 개선한 컴파일러이며, 전체를 컴파일 하지않고 인터프리트가 자주 사용하는 메서드를 캐시(메모리)에 저장하여 추후 해당 메서드를 사용할 때 인터프리터로 해석하는게 아닌 이미 저장된 기계어를 가져온다.

> 

> [!NOTE]
> 자바는 왜 JVM 에 기계어 코드로 바로 변환해서 전달하지 않고, 바이트 코드로 전달하는가?
> 
> 자바의 철학은 "한번 작성하면 어디에서나 실행 가능" 이다. 바이트코드는 기계어로 변환하기 이전 중간 지점이다. 해당 부분을 JVM을 통해 기계어로 변환하는 작업을 갖게 된다면
> Window,Linux,MacOS 등 여러 OS에서 사용할 수 있게 해당 OS에서 읽을 수 있는 기계어로 해석하여 준다.


### 클래스
객체 생성을 위한 설계도이다. 클래스에는 속성과 행동들이 캡슐화화여 데이터 구조를 정의한다. 여기서 캡슐화란 속성과 행동들을 단일 단위 즉, 클래스로 묶는 개념이며 또한 접근제어자를 통해 해당 속성과 행동들에 대하여 접은을 제한 할 수 있는 개념도 포함이다. 

### 객체
클래스의 인스턴스는 객체라고 불리며 객체는 클래스를 통해 만들어진 실제 사물을 뜻하며 자바에서는 무형의 무언가 또한 객체로 불린다.

해당 객체는 new 예약어를 통해 만들어진다.

### 변수
변수는 무언가를 담는 공간을 의미한다. 변수에는 네가지의 종류가 존재한다.
- 인스턴스변수
	- 클래스 내에서 사용할 수 있는 변수이다. 해당 변수는 클래스가 인스턴스화 되었을 때 같이 메모리에 저장된다. 해당 클래스 객체에 참조가 하나도 이루어지지 않을 때 가비지 컬렉션으로 해당 객체가 해제되며 이때 같이 해제된다.
- 정적변수
	- 정적변수는 static 예약어를 통해 만들 수 있으며, 인스턴스 변수와 같은 위치에서 선언된다. 정적변수는 공통으로 사용하고 상수(변하지 않는 값)로 쓰일 때 자주 쓰인다. 해당 변수는 클래스가 인스턴스 되었을 떄 또는 클래스 자체가 선언되었을 때 스태틱 영역, 스태틱 변수, 스태틱 메서드가 Method Area 에 포함된다.
	  
	  해당 변수는 자바프로그램이 실행이 종료되기 전까지 해당 변수의 
-
- 매개변수
	- 메서드에 인풋값을 사용되는 변수이며 해당 변수는 메서드가 호출되고 해당 메서드가 JVM 스택영역에 쌓일때 같이 할당되며 메서드가 종료되었을 때 같이 제거된다.
- 지역변수
	- 중괄호 내에서 선언된 변수를 말하며 해당 중괄호가 종료되었을 때 같이 제거된다.


자바에는 두가지 자료형이 있다.
- 기본자료형
- 참조자료형

기본 자료형은 - byte, short, int, long, float, double, char, boolean 이 8가지이며 나머지는 모두 참조 자료형에 속한다.

기본 자료형타입의 변수는 '값' 그대로를 저장하고 참조형 타입의 참조변수는 해당 객체의 메모리 주소를 저장한다.

그리하여 참조변수에 특정 데이터들을 수정하게 된다면 해당 메모리 주소를 같이 참조하고 있는 다른 변수들에게도 영향을 준다.

------

자바에서 byte, short 는 왜 잘 안쓸까??? Int 형보다 더 적은 메모리를 사용하는데 말이지
-> byte와 short 는 허용하는 정수의 범위가 작아서 연산을 하면 오버플로우가 발생할 가능성이 높으며 자바 자체에서 해당 자료형들을 연산하였을 때 자동으로 int형으로 변환된다. 따라서 byte나 short에서 연산을 수행하더라도 추가적인 처리가 필요하기 때문이다.

그리고 위 내용 바탕으로 굳이 byte, short를 사용할 정도로 메모리가 부족하지 않으므로
굳이 해당 자료형을 쓰기 보다 추가적인 처리 없이 Int형으로 처음부터 쓰는게 좋다.

**그렇다면 왜 연산했을때 지들이 뭔데 int형으로 자동형변환해주나 아래에 최종정리를 해보자**
-> 요즘 CPU 프로세스는 32bit(Int), 64bit(long) 연산을 최적화하여 처리한다. 오히려 더 작은 데이터타입을 처리하는것은 실제로 더 느릴 수 있다.
-> 오버플로우, 언더플로우 방지

### 다형성
다형성이란 하나의 객체가 여러개의 형태를 가질 수 있는것을 의미하며 다형성은 상속과 매우 밀접한 관계에 있다. 
부모클래스 타입의 변수에 각각의 자식객체를 생성한다면 각 변수들에서 함수 호출 시(상속된 abstract class) 자식들마다 오버라이딩한 메서드에 있는 내용을 호출하므로 객체는 모두 하나지만(부모) 여러가지의 형태(자식들마다)를 가질수 있다.

다형성의 장점
- 유지보수: 여러 객체를 하나의 타입으로 관리할 수 있어서 유지보수에 용ㅇ하다
- 재사용성 : 객체의 재사용성이 쉽다
- 느슨한 결합: 클래스 간의 의존성을 줄여 확장성을 높인다.


### 배열
여러 데이터를 한 곳에 저장하고 싶을때 사용하는 자료구조이다. 배열은 선언 시 배열사이즈를 정의해줘야한다. 
리스트 인터페이스를 구현한 ArrayList와는 다른 개념이다.

ArrayList 는 고정된 사이즈를 갖고 있지 않으며 Array(배열)은 고정된 사이즈를 정의해줘야한다.  그리고 배열은 기본형 참조형 모두 담을 수 있지만 **ArrayList는 참조형 객체만 담을 수 있다.** 

--> 왜 참조형만 담을 수 있냐??? ArrayList 클래스를 보면 제네릭이 사용되는걸 알 수 있다.

제네릭이란 형 변환을 통해 일어날 수 있는 오류들과 불편함을 해소하기 위해 나온 것이다. 모든 클래스는 오브젝트 인거처럼 오브젝트 형태에 데이터를 담는다고 보면 String을 담은것도 있을거고 Integer를 담은것도 있을 것이다.  참조변수에서 해당 데이터에 있는 메서드 등을 사용한다고 하면? String 타입인지 Integer인지 확인해야하는 불편함 등~ 있다.

Integer 는 무엇이냐~? Int만 있는거 아니냐?
Integer는 말그대로 제네릭에서 사용할 수 있게 래퍼클래스를 만든것이고 해당 클래스에는 상수 값 등 여러 제공하는 함수및 속성을 사용할 수 있다.

두 개를 사용하는데 있어서 동적인 사이즈를 조절해야하느냐 또는 기본형을 담아야 하느냐 등에 따라 나뉘게 될 거라고 본다.



### 상속

자바는 왜 다중 상속을 막았는가? 
- 다중 상속 시 부모클래스가 되는 A,B 에서 같은 메서드가 선언되어 있을 때 자식클래스에서 어떠한 메서드를 호출해야할지 명확하지 않다
- 결국 복잡성과 유지관리 측면에서 문제가 있따

그렇다면 인터페이스에도 동일한 메서드가 존재할 경우에는 똑같은거 아닌가?
- 메서드 내에서 호출할 메서드를 명시적으로 선택할 수 있다.

```Java
public class MyImplementation implements Interface1, Interface2 { 
@Override 
public void commonMethod() { 
	// 1. 명시적 선언
	Interface1.super.commonMethod();
}

methodFromInterface1
```


### 에러
- checked Exception
- error
- unchecked Exception | runtime exception

모든 예외의 할아버지는 java.lang.Throwable 이다.
- getMessage()
- toString()
- printStackTrace()
- 