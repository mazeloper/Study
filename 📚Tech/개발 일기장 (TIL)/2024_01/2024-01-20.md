

## I/O


### 버퍼
읽거나 쓸 수 있는 고정된 양의 데이터를 위한 컨테이너이며 읽기 모드에서 쓰기 모드로 또는 그 반대로 데이터 전환을 지원한다. 버퍼는 메모리의 두 위치 간에 전송되는 데이터의 임시 보관 장소로 사용된다.

### InputStream / OutputStream
바이트 기반의 데이터를 처리하기 위해서 사용되는 `abstract class` 이다.
읽는 작업은 InputStream 을 통해서, 쓰는 작업은 OutputStream 을 이용한다.



### Reader / Writer
char 기반의 문자열로만 되어 있는 파일을 처리할 수 있다.

----

## Parcelable vs Serialized

'Parcelable'과 'Serialized'는 둘 다 객체 직렬화를 위한 Java의 메커니즘

### 직렬화란
직렬화는 객체의 상태를 저장하거나 전송할 수 있는 형식으로 변환한 다음 이를 사용 가능한 객체 형태로 다시 재구성하는 프로세스이다.
### Parcelable
- 안드로이드에만 해당한다.
- 일반적으로 `Serialized` 보다 빠르다. 액티비티나 프래그먼트 간에 데이터 전달하기 위해 설계되었다.
- 더 많은 코드가 필요하다. 해당 인터페이스를 구현하여 재정의를 해주어야한다.
- 직렬화 프로세스를 더 효과적으로 제어할 수 있다.
- 인텐트 등을 통해 안드로이드 내에서 데이터를 전달하는 데 주로 사용한다

> [!NOTE]
> 인텐트란?
> 메시징 객체로 다른 앱 구성 요소로서 작업을 요청하는데 사용될 수 있다.
> 명시적 인텐트 / 암시적 인텐트가 있다.

### Serializable
- 자바 표준이다. 
- 상대적으로 CPU를 많이 사용하는 프로세스인 객체 상태를 저장하고 복원하기 위해 리플렉션을 사용하므로 `Parcelable` 보다 일반적으로 느리다.
- 구현이 쉽다. 별도의 메소드 없이 Serialized 인터페이스만 구현하면 객체를 직렬화할 수 있다.
- `Pacelable` 에 비해 직렬화 프로세스에 대한 제어가 적다.
- 네트워크 전송, 파일 액세스 또는 심층 복제를 위한 객체 직렬화에 적합하다.


```Java
public class SerializableClass implements Serializable {
  private int mData;
  // transient 객체를 저장할때 해당 변수는 제외된다.
  transient private int password; 
  // 휘발성 (volatile) : 여러 스레드가 작업 완료를 알리기 위해 플래그 변수를 업데이트하고 읽을 수 있는 시나리오에서 해당 블래그를 volatile(휘발성) 으로 선언
  private volatile boolean taskCompleted = false; 
}
```

#### serialVersionUID 를 지정하는 이유는?
1. 버전제어 : 직렬화 가능 클래스의 버전 식별자 역할을 한다. 이는 직렬화된 개체가 이후 버전의 클래스에서 성공적으로 역직렬화 될 수 있도록 도움을 준다.
2. 호환성 검사 : 역직렬화 중에 JVM 은 직렬화된 객체의 serialVersionUID 를 클래스 현재 버전의 UID와 비교한다. 일치하지 않으면 `invalidClassException` 이 발생한다.

### 왜 사용해야할까?
- **데이터 지속성 및 전송:** 두 인터페이스 모두 데이터베이스나 기본 설정과 같은 저장소에 객체 상태를 쉽게 유지하거나 네트워크 연결을 통해 또는 Android 앱 구성 요소 간에 객체를 전송할 수 있습니다.
  
- **특정 사용 사례 요구 사항:** 'Parcelable'은 Android 환경의 성능과 효율성을 위해 선언된 반면, 'Serialized'는 광범위한 Java 애플리케이션에서 사용 편의성과 유연성을 위해 선언되었습니다.
  
- **직렬화 제어:** `Parcelable`은 직렬화 프로세스에 대한 더 많은 제어를 제공하여 개발자가 개체의 각 부분이 직렬화 및 역직렬화되는 방식을 구체적으로 관리할 수 있도록 합니다



---- 

## NIO

자바의 NIO(New I/O) 는 확장 가능한 고성능 I/O 작업에 대한 원래 I/O ('java.io') 의 제한 사항을 해결하기 위해 만들어 졌다.

1. 비차단 I/O : 프로그램 실행을 차단하지 않고 I/O 작업을 수행할 수 있다. 여러 동시 연결을 처리하는 서버 환경에서 확장 가능한 애플리케이션을 개발하는데 중요하다.
2. 버퍼지향: 연속 스트림으로 데이터를 처리하는 스트림지향 I/O 와 달리 NIO는 버퍼지향이다. 데이터는 처리를 위해 버퍼로 읽혀지고 출력을 위해 버퍼에서 기록된다.
3. 채널: 채널은 파일이나 소켓과 같은 I/O 작업을 수행할 수 있는데 엔티티에 대한 연결을 나타낸다.

### Channel

- I/O 작업을 위한 게이트웨이 역할을 하며 읽기/쓰기 둘다 가능하다.
- 비동기 I/O 를 지원하여 멀티 스레드 환경에서 보다 효율적인 작업이 가능하다.
- 유형에는 'FileChannel' , 'SocketChannel' 등이 있다.

---- 
