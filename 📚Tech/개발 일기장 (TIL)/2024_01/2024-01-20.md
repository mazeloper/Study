

## I/O


### 버퍼
읽거나 쓸 수 있는 고정된 양의 데이터를 위한 컨테이너이며 읽기 모드에서 쓰기 모드로 또는 그 반대로 데이터 전환을 지원한다. 버퍼는 메모리의 두 위치 간에 전송되는 데이터의 임시 보관 장소로 사용된다.

### InputStream / OutputStream
바이트 기반의 데이터를 처리하기 위해서 사용되는 `abstract class` 이다.
읽는 작업은 InputStream 을 통해서, 쓰는 작업은 OutputStream 을 이용한다.



### Reader / Writer
char 기반의 문자열로만 되어 있는 파일을 처리할 수 있다.

----

## Parcelable vs Serialized

'Parcelable'과 'Serialized'는 둘 다 객체 직렬화를 위한 Java의 메커니즘

### 직렬화란
직렬화는 객체의 상태를 저장하거나 전송할 수 있는 형식으로 변환한 다음 이를 사용 가능한 객체 형태로 다시 재구성하는 프로세스이다.
### Parcelable
- 안드로이드에만 해당한다.
- 일반적으로 `Serialized` 보다 빠르다. 액티비티나 프래그먼트 간에 데이터 전달하기 위해 설계되었다.
- 더 많은 코드가 필요하다. 해당 인터페이스를 구현하여 재정의를 해주어야한다.
- 직렬화 프로세스를 더 효과적으로 제어할 수 있다.
- 인텐트 등을 통해 안드로이드 내에서 데이터를 전달하는 데 주로 사용한다

> [!NOTE]
> 인텐트란?
> 메시징 객체로 다른 앱 구성 요소로서 작업을 요청하는데 사용될 수 있다.
> 명시적 인텐트 / 암시적 인텐트가 있다.

### Serializable
- 자바 표준이다. 
- 상대적으로 CPU를 많이 사용하는 프로세스인 객체 상태를 저장하고 복원하기 위해 리플렉션을 사용하므로 `Parcelable` 보다 일반적으로 느리다.
- 구현이 쉽다. 별도의 메소드 없이 Serialized 인터페이스만 구현하면 객체를 직렬화할 수 있다.
- `Pacelable` 에 비해 직렬화 프로세스에 대한 제어가 적다.
- 네트워크 전송, 파일 액세스 또는 심층 복제를 위한 객체 직렬화에 적합하다.


```Java
public class SerializableClass implements Serializable {
  private int mData;
  transient private int password; // transient 객체를 저장할때 해당 변수는 제외된다.
}
```

### 왜 사용해야할까?
- **데이터 지속성 및 전송:** 두 인터페이스 모두 데이터베이스나 기본 설정과 같은 저장소에 객체 상태를 쉽게 유지하거나 네트워크 연결을 통해 또는 Android 앱 구성 요소 간에 객체를 전송할 수 있습니다.
  
- **특정 사용 사례 요구 사항:** 'Parcelable'은 Android 환경의 성능과 효율성을 위해 선언된 반면, 'Serialized'는 광범위한 Java 애플리케이션에서 사용 편의성과 유연성을 위해 선언되었습니다.
  
- **직렬화 제어:** `Parcelable`은 직렬화 프로세스에 대한 더 많은 제어를 제공하여 개발자가 개체의 각 부분이 직렬화 및 역직렬화되는 방식을 구체적으로 관리할 수 있도록 합니다.

